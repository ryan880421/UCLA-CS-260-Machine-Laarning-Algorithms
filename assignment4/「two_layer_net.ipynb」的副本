{"cells":[{"cell_type":"code","execution_count":15,"id":"b3161578","metadata":{"id":"b3161578","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1668585595368,"user_tz":480,"elapsed":2067,"user":{"displayName":"YU-RUEI CHANG","userId":"02720537686118125654"}},"outputId":"73608059-c1f0-4306-cffb-4a31914206f8"},"outputs":[{"output_type":"stream","name":"stdout","text":["Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n","/content/drive/My Drive/cs260/assignments/assignment4/cs260/datasets\n","/content/drive/My Drive/cs260/assignments/assignment4\n"]}],"source":["# This mounts your Google Drive to the Colab VM.\n","from google.colab import drive\n","drive.mount('/content/drive')\n","\n","# TODO: Enter the foldername in your Drive where you have saved the unzipped\n","# assignment folder, e.g. 'cs260/assignments/assignment4/'\n","FOLDERNAME = 'cs260/assignments/assignment4/'\n","assert FOLDERNAME is not None, \"[!] Enter the foldername.\"\n","\n","# Now that we've mounted your Drive, this ensures that\n","# the Python interpreter of the Colab VM can load\n","# python files from within it.\n","import sys\n","sys.path.append('/content/drive/My Drive/{}'.format(FOLDERNAME))\n","\n","# This downloads the CIFAR-10 dataset to your Drive\n","# if it doesn't already exist.\n","%cd /content/drive/My\\ Drive/$FOLDERNAME/cs260/datasets/\n","!bash get_datasets.sh\n","%cd /content/drive/My\\ Drive/$FOLDERNAME"]},{"cell_type":"markdown","id":"3045e56c","metadata":{"tags":["pdf-ignore"],"id":"3045e56c"},"source":["# Fully-Connected Neural Nets\n","In this exercise we will implement fully-connected networks using a modular approach. For each layer we will implement a `forward` and a `backward` function. The `forward` function will receive inputs, weights, and other parameters and will return both an output and a `cache` object storing data needed for the backward pass, like this:\n","\n","```python\n","def layer_forward(x, w):\n","  \"\"\" Receive inputs x and weights w \"\"\"\n","  # Do some computations ...\n","  z = # ... some intermediate value\n","  # Do some more computations ...\n","  out = # the output\n","   \n","  cache = (x, w, z, out) # Values we need to compute gradients\n","   \n","  return out, cache\n","```\n","\n","The backward pass will receive upstream derivatives and the `cache` object, and will return gradients with respect to the inputs and weights, like this:\n","\n","```python\n","def layer_backward(dout, cache):\n","  \"\"\"\n","  Receive dout (derivative of loss with respect to outputs) and cache,\n","  and compute derivative with respect to inputs.\n","  \"\"\"\n","  # Unpack cache values\n","  x, w, z, out = cache\n","  \n","  # Use values in cache to compute derivatives\n","  dx = # Derivative of loss with respect to x\n","  dw = # Derivative of loss with respect to w\n","  \n","  return dx, dw\n","```\n","\n","After implementing a bunch of layers this way, we will be able to easily combine them to build classifiers with different architectures.\n","  "]},{"cell_type":"code","execution_count":39,"id":"cd40e03b","metadata":{"tags":["pdf-ignore"],"id":"cd40e03b","colab":{"base_uri":"https://localhost:8080/","height":274},"executionInfo":{"status":"error","timestamp":1668588885989,"user_tz":480,"elapsed":233,"user":{"displayName":"YU-RUEI CHANG","userId":"02720537686118125654"}},"outputId":"c13a014a-838f-47ec-fdda-f98b6d95a317"},"outputs":[{"output_type":"error","ename":"SyntaxError","evalue":"ignored","traceback":["Traceback \u001b[0;36m(most recent call last)\u001b[0m:\n","  File \u001b[1;32m\"/usr/local/lib/python3.7/dist-packages/IPython/core/interactiveshell.py\"\u001b[0m, line \u001b[1;32m3326\u001b[0m, in \u001b[1;35mrun_code\u001b[0m\n    exec(code_obj, self.user_global_ns, self.user_ns)\n","\u001b[0;36m  File \u001b[0;32m\"<ipython-input-39-a9823303b354>\"\u001b[0;36m, line \u001b[0;32m6\u001b[0;36m, in \u001b[0;35m<module>\u001b[0;36m\u001b[0m\n\u001b[0;31m    from cs260.classifiers.fc_net import TwoLayerNet\u001b[0m\n","\u001b[0;36m  File \u001b[0;32m\"/content/drive/MyDrive/cs260/assignments/assignment4/cs260/classifiers/fc_net.py\"\u001b[0;36m, line \u001b[0;32m128\u001b[0m\n\u001b[0;31m    grads['W1'] += self.reg*self.params['W1\u001b[0m\n\u001b[0m                                           ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m EOL while scanning string literal\n"]}],"source":["# As usual, a bit of setup\n","from __future__ import print_function\n","import time\n","import numpy as np\n","import matplotlib.pyplot as plt\n","from cs260.classifiers.fc_net import TwoLayerNet\n","from cs260.data_utils import get_CIFAR10_data\n","from cs260.gradient_check import eval_numerical_gradient, eval_numerical_gradient_array\n","from cs260.solver import Solver\n","\n","%matplotlib inline\n","plt.rcParams['figure.figsize'] = (10.0, 8.0) # set default size of plots\n","plt.rcParams['image.interpolation'] = 'nearest'\n","plt.rcParams['image.cmap'] = 'gray'\n","\n","# for auto-reloading external modules\n","# see http://stackoverflow.com/questions/1907993/autoreload-of-modules-in-ipython\n","%load_ext autoreload\n","%autoreload 2\n","\n","def rel_error(x, y):\n","  \"\"\" returns relative error \"\"\"\n","  return np.max(np.abs(x - y) / (np.maximum(1e-8, np.abs(x) + np.abs(y))))"]},{"cell_type":"code","execution_count":22,"id":"1b6ca973","metadata":{"tags":["pdf-ignore"],"id":"1b6ca973","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1668586286551,"user_tz":480,"elapsed":6451,"user":{"displayName":"YU-RUEI CHANG","userId":"02720537686118125654"}},"outputId":"8de807f2-ceeb-4c6d-f6ae-a815700f2c69"},"outputs":[{"output_type":"stream","name":"stdout","text":["('X_train: ', (49000, 3, 32, 32))\n","('y_train: ', (49000,))\n","('X_val: ', (1000, 3, 32, 32))\n","('y_val: ', (1000,))\n","('X_test: ', (1000, 3, 32, 32))\n","('y_test: ', (1000,))\n"]}],"source":["# Load the (preprocessed) CIFAR10 data.\n","\n","data = get_CIFAR10_data()\n","for k, v in list(data.items()):\n","  print(('%s: ' % k, v.shape))"]},{"cell_type":"markdown","id":"a527a66e","metadata":{"id":"a527a66e"},"source":["# Affine layer: forward\n","Open the file `cs260/layers.py` and implement the `affine_forward` function.\n","\n","Once you are done you can test your implementaion by running the following:"]},{"cell_type":"code","execution_count":31,"id":"26b58b5a","metadata":{"id":"26b58b5a","colab":{"base_uri":"https://localhost:8080/","height":239},"executionInfo":{"status":"error","timestamp":1668586783107,"user_tz":480,"elapsed":893,"user":{"displayName":"YU-RUEI CHANG","userId":"02720537686118125654"}},"outputId":"5f598353-ba98-4f6b-f5d8-14ff61d5f64f"},"outputs":[{"output_type":"error","ename":"NameError","evalue":"ignored","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)","\u001b[0;32m<ipython-input-31-e229c00be2ca>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     12\u001b[0m \u001b[0mb\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlinspace\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m-\u001b[0m\u001b[0;36m0.3\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0.1\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnum\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0moutput_dim\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     13\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 14\u001b[0;31m \u001b[0mout\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0m_\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0maffine_forward\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mw\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mb\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     15\u001b[0m correct_out = np.array([[ 1.49834967,  1.70660132,  1.91485297],\n\u001b[1;32m     16\u001b[0m                         [ 3.25553199,  3.5141327,   3.77273342]])\n","\u001b[0;31mNameError\u001b[0m: name 'affine_forward' is not defined"]}],"source":["# Test the affine_forward function\n","\n","num_inputs = 2\n","input_shape = (4, 5, 6)\n","output_dim = 3\n","\n","input_size = num_inputs * np.prod(input_shape)\n","weight_size = output_dim * np.prod(input_shape)\n","\n","x = np.linspace(-0.1, 0.5, num=input_size).reshape(num_inputs, *input_shape)\n","w = np.linspace(-0.2, 0.3, num=weight_size).reshape(np.prod(input_shape), output_dim)\n","b = np.linspace(-0.3, 0.1, num=output_dim)\n","\n","out, _ = affine_forward(x, w, b)\n","correct_out = np.array([[ 1.49834967,  1.70660132,  1.91485297],\n","                        [ 3.25553199,  3.5141327,   3.77273342]])\n","\n","# Compare your output with ours. The error should be around e-9 or less.\n","print('Testing affine_forward function:')\n","print('difference: ', rel_error(out, correct_out))"]},{"cell_type":"markdown","id":"e9ea1388","metadata":{"id":"e9ea1388"},"source":["# Affine layer: backward\n","Now implement the `affine_backward` function and test your implementation using numeric gradient checking."]},{"cell_type":"code","execution_count":null,"id":"da91c872","metadata":{"id":"da91c872"},"outputs":[],"source":["# Test the affine_backward function\n","np.random.seed(231)\n","x = np.random.randn(10, 2, 3)\n","w = np.random.randn(6, 5)\n","b = np.random.randn(5)\n","dout = np.random.randn(10, 5)\n","\n","dx_num = eval_numerical_gradient_array(lambda x: affine_forward(x, w, b)[0], x, dout)\n","dw_num = eval_numerical_gradient_array(lambda w: affine_forward(x, w, b)[0], w, dout)\n","db_num = eval_numerical_gradient_array(lambda b: affine_forward(x, w, b)[0], b, dout)\n","\n","_, cache = affine_forward(x, w, b)\n","dx, dw, db = affine_backward(dout, cache)\n","\n","# The error should be around e-10 or less\n","print('Testing affine_backward function:')\n","print('dx error: ', rel_error(dx_num, dx))\n","print('dw error: ', rel_error(dw_num, dw))\n","print('db error: ', rel_error(db_num, db))"]},{"cell_type":"markdown","id":"5c270c0b","metadata":{"id":"5c270c0b"},"source":["# ReLU activation: forward\n","Implement the forward pass for the ReLU activation function in the `relu_forward` function and test your implementation using the following:"]},{"cell_type":"code","execution_count":null,"id":"73ea11eb","metadata":{"id":"73ea11eb"},"outputs":[],"source":["# Test the relu_forward function\n","\n","x = np.linspace(-0.5, 0.5, num=12).reshape(3, 4)\n","\n","out, _ = relu_forward(x)\n","correct_out = np.array([[ 0.,          0.,          0.,          0.,        ],\n","                        [ 0.,          0.,          0.04545455,  0.13636364,],\n","                        [ 0.22727273,  0.31818182,  0.40909091,  0.5,       ]])\n","\n","# Compare your output with ours. The error should be on the order of e-8\n","print('Testing relu_forward function:')\n","print('difference: ', rel_error(out, correct_out))"]},{"cell_type":"markdown","id":"ed1e97af","metadata":{"id":"ed1e97af"},"source":["# ReLU activation: backward\n","Now implement the backward pass for the ReLU activation function in the `relu_backward` function and test your implementation using numeric gradient checking:"]},{"cell_type":"code","execution_count":null,"id":"4852deab","metadata":{"id":"4852deab"},"outputs":[],"source":["np.random.seed(231)\n","x = np.random.randn(10, 10)\n","dout = np.random.randn(*x.shape)\n","\n","dx_num = eval_numerical_gradient_array(lambda x: relu_forward(x)[0], x, dout)\n","\n","_, cache = relu_forward(x)\n","dx = relu_backward(dout, cache)\n","\n","# The error should be on the order of e-12\n","print('Testing relu_backward function:')\n","print('dx error: ', rel_error(dx_num, dx))"]},{"cell_type":"markdown","id":"2116f9e2","metadata":{"tags":["pdf-inline"],"id":"2116f9e2"},"source":["## Inline Question 1: \n","\n","We've only asked you to implement ReLU, but there are a number of different activation functions that one could use in neural networks, each with its pros and cons. In particular, an issue commonly seen with activation functions is getting zero (or close to zero) gradient flow during backpropagation. Which of the following activation functions have this problem? If you consider these functions in the one dimensional case, what types of input would lead to this behaviour?\n","1. Sigmoid\n","2. ReLU\n","3. Tanh\n","\n","## Answer:\n","1) sigmoid  :-\n",". The main reason why we use the sigmoid function is that it exist between( 0 to1).\n",". therefore ,it is especially useful for models where we have to predict the probability as an output.\n",". since the probability of anything exist only between the range of 0 and 1, sigmoid is the right choice.\n",". The sigmoid function plays an important role in the field of machine learning and is considered as one of the most widely used so-called activation functions\n",". More specifically in the contents of Logistic regression the signal is used to predict the outcome of binary classification problems.\n",". It is the difference table real function define for real input values and containing positive derivatives everywhere with a specific degree of smoothness\n",". The sigmoid function appears in the output layer of the deep learning models and is used for predicting probability based outputs\n",". The sigmoid function is represented as\n","A= 1/1+e–x\n",". The graph of the sigmoid function is 'S' shape\n",". It is non linear in nature\n",". We can stack layer\n",". Combination of this function are also non linear\n",". It has a smooth gradient too\n","\n","*pros :\n","- smooth gradient preventing jumps in output values\n","- output values bond between 0 and 1 normalising the output of each neurone therefore it is especially useful for models where we have to predict the probability as an output S\n",". Clear prediction\n",". Unlike linear function the output of the activation function is always going to be in range( 0 ,1) compare to (-inf,inf) of linear function\n","So we have our activation bound in a range\n","\n","*Cons :\n","- vanishing gradient: for very hai aur very low values of X there is almost no change to the prediction causing advising gradient problem this can result in the network refusing to learn further or being too slow to reach an accurate prediction.\n",". Outputs not zero centred\n",". Computationally expensive.\n","\n","2)ReLu (Rectified linear unit )\n",".ReLu activation function is one of the most popular activation functions for deep learning and convolutional neural networks.\n",". However the function itself is deceptively simple.\n",". The rectified linear activation function or Relu for short is a piecewise linear function that will output the input directly if it is positive otherwise it will output 0\n",". The rectified linear activation function overcomes the vanishing gradient problem allowing models to learn faster and perform better\n","\n","\n","*Pros :\n","- allows to avoid vanishing gradient problem\n","_ computationally efficient\n","- it is a less computationally expensive than sigmoid\n","\n","*Cons :\n","- the dying relu problem when input approach zero or negative the gradient of the function becomes zero the network cannot perform backpropagation and cannot learn\n","- one of its limitation is that it should only be used within hidden layers of a neural network model\n","\n","3)leaky ReLu :\n","\n",". Leaky ReLu is one attempt to fix the dying ReLu or dead neurones problems.\n",". Instead of the function being zero when X<0,a leaky ReLu will instead have a small negative slope(of 0.01.or so)\n",". That is the function computes f(X)=1(X<0)(ax)+1(X>=0)\n",". Some people report success with this form of activation function but the result are not always consistent.\n","\n","*Cons :\n","- Leaky relu does not provide consistent predictions for negative input values\n","\n","*Pros :\n","- allows the negative slope to be learn otherwise like ReLu.\n"]},{"cell_type":"markdown","id":"c8cdb366","metadata":{"id":"c8cdb366"},"source":["# \"Sandwich\" layers\n","There are some common patterns of layers that are frequently used in neural nets. For example, affine layers are frequently followed by a ReLU nonlinearity. To make these common patterns easy, we define several convenience layers in the file `cs231n/layer_utils.py`.\n","\n","For now take a look at the `affine_relu_forward` and `affine_relu_backward` functions, and run the following to numerically gradient check the backward pass:"]},{"cell_type":"code","execution_count":null,"id":"0ce1580a","metadata":{"id":"0ce1580a"},"outputs":[],"source":["from cs260.layer_utils import affine_relu_forward, affine_relu_backward\n","np.random.seed(231)\n","x = np.random.randn(2, 3, 4)\n","w = np.random.randn(12, 10)\n","b = np.random.randn(10)\n","dout = np.random.randn(2, 10)\n","\n","out, cache = affine_relu_forward(x, w, b)\n","dx, dw, db = affine_relu_backward(dout, cache)\n","\n","dx_num = eval_numerical_gradient_array(lambda x: affine_relu_forward(x, w, b)[0], x, dout)\n","dw_num = eval_numerical_gradient_array(lambda w: affine_relu_forward(x, w, b)[0], w, dout)\n","db_num = eval_numerical_gradient_array(lambda b: affine_relu_forward(x, w, b)[0], b, dout)\n","\n","# Relative error should be around e-10 or less\n","print('Testing affine_relu_forward and affine_relu_backward:')\n","print('dx error: ', rel_error(dx_num, dx))\n","print('dw error: ', rel_error(dw_num, dw))\n","print('db error: ', rel_error(db_num, db))"]},{"cell_type":"markdown","id":"caf21167","metadata":{"id":"caf21167"},"source":["# Loss layer: Softmax\n","Now implement the loss and gradient for softmax in the `softmax_loss` function in `cs260/layers.py`. This should be similar to what you implemented in `cs260/classifiers/softmax.py`.\n","\n","You can make sure that the implementations are correct by running the following:"]},{"cell_type":"code","execution_count":null,"id":"e14d422b","metadata":{"id":"e14d422b"},"outputs":[],"source":["np.random.seed(231)\n","num_classes, num_inputs = 10, 50\n","x = 0.001 * np.random.randn(num_inputs, num_classes)\n","y = np.random.randint(num_classes, size=num_inputs)\n","\n","dx_num = eval_numerical_gradient(lambda x: softmax_loss(x, y)[0], x, verbose=False)\n","loss, dx = softmax_loss(x, y)\n","\n","# Test softmax_loss function. Loss should be close to 2.3 and dx error should be around e-8\n","print('\\nTesting softmax_loss:')\n","print('loss: ', loss)\n","print('dx error: ', rel_error(dx_num, dx))"]},{"cell_type":"markdown","id":"8f739e24","metadata":{"id":"8f739e24"},"source":["# Two-layer network\n","Open the file `cs260/classifiers/fc_net.py` and complete the implementation of the `TwoLayerNet` class. Read through it to make sure you understand the API. You can run the cell below to test your implementation."]},{"cell_type":"code","execution_count":null,"id":"b8ed0018","metadata":{"id":"b8ed0018"},"outputs":[],"source":["np.random.seed(231)\n","N, D, H, C = 3, 5, 50, 7\n","X = np.random.randn(N, D)\n","y = np.random.randint(C, size=N)\n","\n","std = 1e-3\n","model = TwoLayerNet(input_dim=D, hidden_dim=H, num_classes=C, weight_scale=std)\n","\n","print('Testing initialization ... ')\n","W1_std = abs(model.params['W1'].std() - std)\n","b1 = model.params['b1']\n","W2_std = abs(model.params['W2'].std() - std)\n","b2 = model.params['b2']\n","assert W1_std < std / 10, 'First layer weights do not seem right'\n","assert np.all(b1 == 0), 'First layer biases do not seem right'\n","assert W2_std < std / 10, 'Second layer weights do not seem right'\n","assert np.all(b2 == 0), 'Second layer biases do not seem right'\n","\n","print('Testing test-time forward pass ... ')\n","model.params['W1'] = np.linspace(-0.7, 0.3, num=D*H).reshape(D, H)\n","model.params['b1'] = np.linspace(-0.1, 0.9, num=H)\n","model.params['W2'] = np.linspace(-0.3, 0.4, num=H*C).reshape(H, C)\n","model.params['b2'] = np.linspace(-0.9, 0.1, num=C)\n","X = np.linspace(-5.5, 4.5, num=N*D).reshape(D, N).T\n","scores = model.loss(X)\n","correct_scores = np.asarray(\n","  [[11.53165108,  12.2917344,   13.05181771,  13.81190102,  14.57198434, 15.33206765,  16.09215096],\n","   [12.05769098,  12.74614105,  13.43459113,  14.1230412,   14.81149128, 15.49994135,  16.18839143],\n","   [12.58373087,  13.20054771,  13.81736455,  14.43418138,  15.05099822, 15.66781506,  16.2846319 ]])\n","scores_diff = np.abs(scores - correct_scores).sum()\n","assert scores_diff < 1e-6, 'Problem with test-time forward pass'\n","\n","print('Testing training loss (no regularization)')\n","y = np.asarray([0, 5, 1])\n","loss, grads = model.loss(X, y)\n","correct_loss = 3.4702243556\n","assert abs(loss - correct_loss) < 1e-10, 'Problem with training-time loss'\n","\n","model.reg = 1.0\n","loss, grads = model.loss(X, y)\n","correct_loss = 26.5948426952\n","assert abs(loss - correct_loss) < 1e-10, 'Problem with regularization loss'\n","\n","# Errors should be around e-7 or less\n","for reg in [0.0, 0.7]:\n","  print('Running numeric gradient check with reg = ', reg)\n","  model.reg = reg\n","  loss, grads = model.loss(X, y)\n","\n","  for name in sorted(grads):\n","    f = lambda _: model.loss(X, y)[0]\n","    grad_num = eval_numerical_gradient(f, model.params[name], verbose=False)\n","    print('%s relative error: %.2e' % (name, rel_error(grad_num, grads[name])))"]},{"cell_type":"markdown","id":"21f67545","metadata":{"id":"21f67545"},"source":["# Solver\n","Open the file `cs260/solver.py` and read through it to familiarize yourself with the API. After doing so, use a `Solver` instance to train a `TwoLayerNet` that achieves about `30%` accuracy on the validation set."]},{"cell_type":"code","execution_count":null,"id":"cf423ed9","metadata":{"id":"cf423ed9"},"outputs":[],"source":["input_size = 32 * 32 * 3\n","hidden_size = 50\n","num_classes = 10\n","model = TwoLayerNet(input_size, hidden_size, num_classes)\n","solver = None\n","\n","##############################################################################\n","# TODO: Use a Solver instance to train a TwoLayerNet that achieves about 30% #\n","# accuracy on the validation set. Use SGD as your update rule and a learning #\n","# rate of 1e-5. (Everything else should be default parameters.)              #\n","##############################################################################\n","# *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n","def generate_random_hyperparams(lr, reg, hidden_size, epoch_values):\n","    lr = 10**np.random.uniform(lr[0], lr[1])\n","    reg = 10**np.random.uniform(reg[0], reg[1])\n","    hidden_size = np.random.randint(hidden_size[0], hidden_size[1])\n","    epochs = epoch_values[np.random.randint(0, len(epoch_values))]\n","\n","    return lr, reg, hidden_size, epochs\n","\n","# number of hypercombinations combinations to look for\n","num_hyperparam_configs = 10\n","\n","# form random combinations of learning_rate, regularization_strength, hidden_layer_size and num_training_epochs\n","grid_search = [generate_random_hyperparams((-2, -4), (-7, -3), (50, 100, 200), (10, 20))\n","               for count in range(num_hyperparam_configs)]\n","\n","# get our data\n","# data = get_CIFAR10_data()            \n","\n","best_val = -1   # The highest validation accuracy that we have seen so far.\n","results = {}\n","\n","for config_num, config in enumerate(grid_search):\n","    print(\"Hyperparam config #{} of #{}: \".format(config_num+1, len(grid_search)), end='')\n","\n","    lr, reg, hidden_size, epochs = config\n","    print(\"lr: {:.2e}, reg: {:.2e}, hidden_size: {:.2e}, epochs: {:.2e}\".format(lr, reg, hidden_size, epochs))\n","\n","    model = TwoLayerNet(hidden_dim=hidden_size, reg=reg)\n","    current_solver = Solver(model, data, update_rule='sgd', optim_config={'learning_rate': lr},\n","                            lr_decay=0.95, num_epochs=epochs, batch_size=100, \n","                            print_every=100, verbose=False)\n","\n","    # train a 2-layer neural net on the training set\n","    current_solver.train()\n","    \n","    # store the best validation accuracy and the TwoLayerNet object\n","    if current_solver.best_val_acc > best_val: \n","        best_val = current_solver.best_val_acc\n","        solver = current_solver\n","\n","    # print results in-line to avoid saving them\n","    print('Validation accuracy: %.4f' % (solver.best_val_acc,))\n","    print() # new line after every hyperparam config\n","    \n","print('Best validation accuracy achieved: %.4f' % best_val)\n","\n","\n","# *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n","##############################################################################\n","#                             END OF YOUR CODE                               #\n","##############################################################################"]},{"cell_type":"markdown","id":"c1245160","metadata":{"id":"c1245160"},"source":["# Debug the training\n","With the default parameters we provided above, you should get a validation accuracy of about 0.30 on the validation set. This isn't very good.\n","\n","One strategy for getting insight into what's wrong is to plot the loss function and the accuracies on the training and validation sets during optimization.\n","\n","Another strategy is to visualize the weights that were learned in the first layer of the network. In most neural networks trained on visual data, the first layer weights typically show some visible structure when visualized."]},{"cell_type":"code","execution_count":null,"id":"1788b1a0","metadata":{"id":"1788b1a0"},"outputs":[],"source":["# Run this cell to visualize training loss and train / val accuracy\n","\n","plt.subplot(2, 1, 1)\n","plt.title('Training loss')\n","plt.plot(solver.loss_history, 'o')\n","plt.xlabel('Iteration')\n","\n","plt.subplot(2, 1, 2)\n","plt.title('Accuracy')\n","plt.plot(solver.train_acc_history, '-o', label='train')\n","plt.plot(solver.val_acc_history, '-o', label='val')\n","plt.plot([0.5] * len(solver.val_acc_history), 'k--')\n","plt.xlabel('Epoch')\n","plt.legend(loc='lower right')\n","plt.gcf().set_size_inches(15, 12)\n","plt.show()"]},{"cell_type":"code","execution_count":null,"id":"9ddfe290","metadata":{"id":"9ddfe290"},"outputs":[],"source":["from cs260.vis_utils import visualize_grid\n","\n","# Visualize the weights of the network\n","\n","def show_net_weights(net):\n","    W1 = net.params['W1']\n","    W1 = W1.reshape(3, 32, 32, -1).transpose(3, 1, 2, 0)\n","    plt.imshow(visualize_grid(W1, padding=3).astype('uint8'))\n","    plt.gca().axis('off')\n","    plt.show()\n","\n","show_net_weights(model)"]},{"cell_type":"markdown","id":"5d2a0395","metadata":{"id":"5d2a0395"},"source":["# Tune your hyperparameters\n","\n","**What's wrong?**. Looking at the visualizations above, we see that the loss is decreasing more or less linearly, which seems to suggest that the learning rate may be too low. Moreover, there is no gap between the training and validation accuracy, suggesting that the model we used has low capacity, and that we should increase its size. On the other hand, with a very large model we would expect to see more overfitting, which would manifest itself as a very large gap between the training and validation accuracy.\n","\n","**Tuning**. Tuning the hyperparameters and developing intuition for how they affect the final performance is a large part of using Neural Networks, so we want you to get a lot of practice. Below, you should experiment with different values of the various hyperparameters, including hidden layer size, learning rate, numer of training epochs, and regularization strength. You might also consider tuning the learning rate decay, but you should be able to get good performance using the default value.\n","\n","**Approximate results**. You should be aim to achieve a classification accuracy of greater than 48% on the validation set. Our best network gets over 52% on the validation set.\n","\n","**Experiment**: You goal in this exercise is to get as good of a result on CIFAR-10 as you can (52% could serve as a reference), with a fully-connected Neural Network. Feel free implement your own techniques (e.g. PCA to reduce dimensionality, or adding dropout, or adding features to the solver, etc.)."]},{"cell_type":"code","execution_count":null,"id":"d71f821d","metadata":{"scrolled":false,"id":"d71f821d"},"outputs":[],"source":["best_model = None\n","\n","\n","#################################################################################\n","# TODO: Tune hyperparameters using the validation set. Store your best trained  #\n","# model in best_model.                                                          #\n","#                                                                               #\n","# To help debug your network, it may help to use visualizations similar to the  #\n","# ones we used above; these visualizations will have significant qualitative    #\n","# differences from the ones we saw above for the poorly tuned network.          #\n","#                                                                               #\n","# Tweaking hyperparameters by hand can be fun, but you might find it useful to  #\n","# write code to sweep through possible combinations of hyperparameters          #\n","# automatically like we did on thexs previous exercises.                          #\n","#################################################################################\n","# *****START OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n","\n","best_model = None\n","def hyperparameter_train(hidden_size, reg, lr, lr_decay, num_iters):\n","    input_size = 32 * 32 * 3\n","    num_classes = 10\n","\n","    net = TwoLayerNet(input_size, hidden_size, num_classes)\n","\n","    # Train the network\n","    stats = net.train(X_train, y_train, X_val, y_val,\n","                      num_iters=num_iters, batch_size=200,\n","                      learning_rate=lr, learning_rate_decay=lr_decay,\n","                      reg=reg, verbose=True)\n","    return net, stats\n","\n","best_net, stats = hyperparameter_train(hidden_size=200, reg=0.03, lr=1e-3, lr_decay=0.9, num_iters=2000)\n","print(f\"Val accuracy: {stats['val_acc_history'][-1]*100:.2f}\")\n","plot_training(stats)\n","\n","\n","# *****END OF YOUR CODE (DO NOT DELETE/MODIFY THIS LINE)*****\n","################################################################################\n","#                              END OF YOUR CODE                                #\n","################################################################################"]},{"cell_type":"markdown","id":"7e50c1dc","metadata":{"id":"7e50c1dc"},"source":["# Test your model!\n","Run your best model on the validation and test sets. You should achieve above 45% accuracy on the validation set and the test set."]},{"cell_type":"code","execution_count":null,"id":"a14cf538","metadata":{"test":"val_accuracy","id":"a14cf538"},"outputs":[],"source":["y_val_pred = np.argmax(best_model.loss(data['X_val']), axis=1)\n","print('Validation set accuracy: ', (y_val_pred == data['y_val']).mean())"]},{"cell_type":"code","execution_count":null,"id":"1a018fc4","metadata":{"test":"test_accuracy","id":"1a018fc4"},"outputs":[],"source":["y_test_pred = np.argmax(best_model.loss(data['X_test']), axis=1)\n","print('Test set accuracy: ', (y_test_pred == data['y_test']).mean())"]},{"cell_type":"markdown","id":"9e78df2a","metadata":{"id":"9e78df2a"},"source":["## Inline Question 2: \n","\n","Now that you have trained a Neural Network classifier, you may find that your testing accuracy is much lower than the training accuracy. In what ways can we decrease this gap? Select all that apply.\n","\n","1. Train on a larger dataset.\n","2. Add more hidden units.\n","3. Increase the regularization strength.\n","4. None of the above.\n","\n","$\\color{blue}{\\textit Your Answer:}$\n","\n","1 . Train on a larger dataset.\n","\n","3 . Increase the regularization strength.\n","\n","$\\color{blue}{\\textit Your Explanation:}$\n","\n","The gap is caused by the hyperparameters overfitting the validation set. To reduce this gap, we can increase the training size or increase regularization strength to prevent overfitting. In addition, we can use cross-validation instead of a single validation set to tune hyperparameters.\n","\n"]},{"cell_type":"code","execution_count":null,"id":"260c3fbd","metadata":{"id":"260c3fbd"},"outputs":[],"source":[]}],"metadata":{"colab":{"provenance":[{"file_id":"1W0UepkLUSRtYfFrpMnv49iGm6Ij7XBvN","timestamp":1668576451462}]},"language_info":{"name":"python"},"kernelspec":{"name":"python3","display_name":"Python 3"},"gpuClass":"standard"},"nbformat":4,"nbformat_minor":5}